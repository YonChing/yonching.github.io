##################################
RocketMQ的NameServer
##################################

*****************************
路由注册
*****************************

NameServer的无状态的，各个NameServer不进行信息通信。每个Broker有一个NameServer列表，Broker启动时，与每个NameServer建立长连接，发起注册请求。
NameServer内部维护这一个Broker列表，动态存储Broker的信息。
优点：因为无状态，所以搭建集群简单
缺点：NameServer不能随便扩容，因为要修改所有Broker的NameServer列表

Broker会30秒发送一次心跳，将自身属性信息发给NameServer，NameServer接收到心跳包后更新Broker信息。

******************************
路由剔除
******************************

NameServer中有一个定时任务，每隔十秒扫描一次Broker表，查看最新心跳时间戳是否超过120秒，如果超过，则判定Broker实效，将其从列表中剔除。

*******************************
路由发现
*******************************

采用的是Pull模型，当路由变化时，NameServer不会主动推送给客户端，默认客户端每30秒拉取最新的路由。
缺点：实时性不高

***********************************
客户端选择NameServer策略
***********************************

 * 首先随机数取模
 * 随机失败后，用round-robin


 
####################################
Eureka
####################################


**************************************
自我保护机制
**************************************

默认情况下，如果 Eureka Server 在一段时间内（默认为 90 秒）没有接收到某个服务提供者（Eureka Client）的心跳，就会将这个服务提供者提供的服务从服务注册表中移除。 这样服务消费者就再也无法从服务注册中心中获取到这个服务了，更无法调用该服务。

但在实际的分布式微服务系统中，健康的服务（Eureka Client）也有可能会由于网络故障（例如网络延迟、卡顿、拥挤等原因）而无法与 Eureka Server 正常通讯。若此时 Eureka Server 因为没有接收心跳而误将健康的服务从服务列表中移除，这显然是不合理的。而 Eureka 的自我保护机制就是来解决此问题的。

所谓 “Eureka 的自我保护机制”，其中心思想就是“好死不如赖活着”。如果 Eureka Server 在一段时间内没有接收到 Eureka Client 的心跳，那么 Eureka Server 就会开启自我保护模式，将所有的 Eureka Client 的注册信息保护起来，而不是直接从服务注册表中移除。一旦网络恢复，这些 Eureka Client 提供的服务还可以继续被服务消费者消费。

综上，Eureka 的自我保护机制是一种应对网络异常的安全保护措施。它的架构哲学是：宁可同时保留所有微服务（健康的服务和不健康的服务都会保留）也不盲目移除任何健康的服务。通过 Eureka 的自我保护机制，可以让 Eureka Server 集群更加的健壮、稳定。

    Eureka 的自我保护机制也存在弊端。如果在 Eureka 自我保护机制触发期间，服务提供者提供的服务出现问题，那么服务消费者就很容易获取到已经不存在的服务进而出现调用失败的情况，此时，我们可以通过客户端的容错机制来解决此问题，详情请参考 Spring Cloud Netflix Ribbon 和 Spring Cloud Netflix Hystrix。


**************************************
集群
**************************************

服务注册中心是不能将自己注册到自己身上的，但服务注册中心是可以将自己作为服务向其他的服务注册中心注册自己的。

举个例子，有两个 Eureka Server 分别为 A 和 B，虽然 A 不能将自己注册到 A 上，B 也不能将自己注册到 B 上，但 A 是可以作为一个服务把自己注册到 B 上的，同理 B 也可以将自己注册到 A 上。

这样就可以形成一组互相注册的 Eureka Server 集群，当服务提供者发送注册请求到 Eureka Server 时，Eureka Server 会将请求转发给集群中所有与之相连的 Eureka Server 上，以实现 Eureka Server 之间的服务同步。

通过服务同步，服务消费者可以在集群中的任意一台 Eureka Server 上获取服务提供者提供的服务。这样，即使集群中的某个服务注册中心发生故障，服务消费者仍然可以从集群中的其他 Eureka Server 中获取服务信息并调用，而不会导致系统的整体瘫痪，这就是 Eureka Server 集群的高可用性。 


****************************************
动态扩容
****************************************

实现的目标：eureka server无论是扩缩容还是故障K8S飘逸节点后(更换IP)后都能重新组合成新的集群，无需更改任何eureka server和微服务的配置。把eureka server完全当做一个无状态节点部署，无需K8S做任何改动。



要想实现自动扩容，要考虑以下几点：

    1. 要有心跳更新，过期自动剔除，这样就需要eureka节点定期注册心跳
    2. eureka server集群中的每个节点定期更新配置组成集群
    3. 每个微服务的eureka client也要定期更新server配置，防止server扩缩容后client不感知
    4. 既然不用配置文件，就需要在eureka server启动时就去连接数据库注册自己并获得其他节点配置。微服务中的client启动时去数据库拿server配置。

    关于Eureka集群部署类似于ZK，需要把集群中每个节点信息都配置到配置文件中，在云原生时代，K8S部署Eureka时每个节点要有不同的配置文件，所以需要用statfulset的方式部署。上篇文章介绍过集群部署的三个方案及其优劣，如下所示：

    1. 双节点自动配置
    * 采用脚本方案，启动查数据库，设置defaultZone，但是此种方式挂了重启重新分配ip时集群其他节点不会动态更新
    2. 采用配置文件方式，使用服务名来配置集群，每个节点是一个服务，client也配置服务名
    * 使用K8S服务名配置，设置eureka为DNS注册方式
    * eureka可以动态加载配置文件，可实现扩缩容，但是扩缩容后微服务不感知，除非也修改微服务的配置文件
    3. 重新实现eureka获取defaultZone的方式
    * 重新实现获取defaultZone，让其读取数据库，实现动态加载
    本文详细介绍第三种方案

